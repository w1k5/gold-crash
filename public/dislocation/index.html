<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üåà</text></svg>">
  <title>Dislocation Detector</title>
  <style>
    :root {
      color-scheme: light dark;
      --green: #2d6a4f;
      --blue: #2563eb;
      --orange: #f97316;
      --red: #b91c1c;
      --gray: #334155;
      --bg: #f8fafc;
      --card: #ffffff;
      --text: #0f172a;
      --muted: #64748b;
      --border: #e2e8f0;
      --shadow: 0 10px 30px rgba(15, 23, 42, 0.08);
      --row-alt: #f8fafc;
      --code-bg: #0b1020;
      --code-text: #e2e8f0;
    }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
    }
    main {
      max-width: 980px;
      margin: 0 auto;
      padding: 32px 20px 64px;
    }
    header {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    h1 {
      margin: 0;
      font-size: 32px;
      letter-spacing: -0.02em;
    }
    .hero {
      display: flex;
      flex-direction: column;
      gap: 14px;
      background: var(--card);
      border-radius: 20px;
      padding: 22px;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
    }
    .header-note {
      font-size: 14px;
      color: var(--muted);
      margin: 0;
    }
    .meta-note {
      font-size: 13px;
      color: var(--muted);
      margin: 0;
      line-height: 1.5;
    }
    .section {
      margin-top: 28px;
    }
    .section-card {
      background: var(--card);
      border-radius: 14px;
      padding: 18px 20px;
      border: 1px solid var(--border);
      margin-top: 16px;
    }
    .section-explainer {
      margin: 6px 0 0;
      font-size: 14px;
      color: var(--muted);
    }
    ul {
      margin: 12px 0 0;
      padding-left: 20px;
    }
    li {
      margin-bottom: 8px;
    }
    li:last-child {
      margin-bottom: 0;
    }
    pre {
      margin: 16px 0 0;
      background: var(--code-bg);
      color: var(--code-text);
      padding: 16px;
      border-radius: 12px;
      overflow-x: auto;
      border: 1px solid #111827;
      font-size: 13px;
      line-height: 1.5;
    }
    code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    blockquote {
      margin: 16px 0 0;
      padding: 12px 16px;
      border-left: 4px solid var(--orange);
      background: rgba(249, 115, 22, 0.08);
      border-radius: 10px;
      color: var(--text);
    }
    a {
      color: var(--blue);
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }
    @media (max-width: 700px) {
      main {
        padding: 24px 16px 40px;
      }
      .hero {
        padding: 18px;
      }
      pre {
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <main>
    <header>
      <div class="hero">
        <h1>Dislocation Detector</h1>
        <p class="header-note">A low-churn checklist turned into a daily dislocation signal using free market data.</p>
        <p class="meta-note"><a href="/">‚Üê Back to Gold Risk Monitor</a></p>
      </div>
    </header>

    <section class="section">
      <h2>Current status</h2>
      <p class="section-explainer">Pulled from the latest <code>dislocation.json</code> run in the daily workflow.</p>
      <div class="section-card">
        <p id="dislocationStatus"><strong>Status:</strong> Loading...</p>
        <p class="meta-note" id="dislocationTimestamp">As of: Loading...</p>
        <p class="meta-note" id="dislocationRule">Rule: Loading...</p>
        <p class="meta-note"><strong>Signals triggered:</strong></p>
        <ul id="dislocationSignals">
          <li>Loading signal details...</li>
        </ul>
      </div>
    </section>

    <section class="section">
      <h2>Overview</h2>
      <p class="section-explainer">Yes. You can turn that checklist into a <strong>stable, low-churn ‚Äúdislocation detector‚Äù</strong> that runs daily, pulls <strong>free public market data</strong>, and only triggers when <strong>multiple, smoothed signals</strong> agree.</p>
      <div class="section-card">
        <p>This Python script does the following:</p>
        <ul>
          <li>Scrapes <strong>daily OHLCV</strong> from <strong>Stooq</strong> (no API key) for: SPY proxy, VTI proxy, GLD, HYG, and VIX.</li>
          <li>Computes <strong>robust signals</strong> (not twitchy):
            <ul>
              <li>‚ÄúBig down + whipsaw‚Äù (large down day + unusually large intraday range vs its own history)</li>
              <li>‚ÄúVolatility spike‚Äù (VIX level + VIX jump vs its own history)</li>
              <li>‚ÄúCredit stress‚Äù (HYG underperforms SPY by a lot, plus optional FRED spread if you add a key)</li>
              <li>‚ÄúEverything sells together‚Äù (equities down hard and gold down too)</li>
              <li>‚ÄúLiquidity degraded‚Äù <em>proxy</em> (volume + range spike; true bid/ask spreads aren‚Äôt reliably accessible free)</li>
            </ul>
          </li>
          <li>Uses <strong>persistence</strong> (e.g., must meet criteria today and/or within last N days) to reduce false alarms.</li>
          <li>Outputs a <strong>single ‚Äúdislocation: true/false‚Äù</strong> plus which signals fired.</li>
        </ul>
        <blockquote>
          ‚ö†Ô∏è Note on ‚Äúbid‚Äìask spreads‚Äù: truly accurate spreads require market data feeds (IEX/Polygon/Alpaca/etc). Without that, the best low-volatility proxy is <strong>range spike + volume spike + gapiness</strong>.
        </blockquote>
      </div>
    </section>

    <section class="section">
      <h2>Python script: dislocation_detector.py</h2>
      <div class="section-card">
        <pre><code>#!/usr/bin/env python3
"""
Dislocation detector (daily, low-churn) using free data (Stooq) + optional FRED.

Goal: flag likely "flow-driven dislocation" when &gt;=K signals are true,
with smoothing/persistence to avoid noise.

Data source: Stooq daily CSV (no API key)
Optional: FRED high-yield spread series (requires FRED_API_KEY env var)
"""

from __future__ import annotations

import argparse
import json
import os
from dataclasses import dataclass
from datetime import datetime, timezone
from io import StringIO
from typing import Dict, List, Optional, Tuple

import pandas as pd
import requests


# -----------------------------
# Data fetch (Stooq, free)
# -----------------------------

STOOQ_DAILY = "https://stooq.com/q/d/l/?s={symbol}&i=d"

# Stooq tickers:
# - S&amp;P 500 ETF proxy: "spy.us" (Stooq usually has it)
# - Total market proxy: "vti.us"
# - Gold: "gld.us"
# - High yield credit ETF proxy: "hyg.us"
# - VIX index: "^vix" often works on Stooq as "vix" or "^vix"
#   Stooq uses "vix" for the VIX index in many cases.
DEFAULT_TICKERS = {
    "equity_core": "spy.us",
    "equity_broad": "vti.us",
    "gold": "gld.us",
    "credit_hy": "hyg.us",
    "vix": "vix",  # if this fails, try "^vix" manually
}


def fetch_stooq_daily(symbol: str) -&gt; pd.DataFrame:
    url = STOOQ_DAILY.format(symbol=symbol)
    response = requests.get(url, timeout=20)
    response.raise_for_status()
    if "&lt;html" in response.text.lower():
        raise ValueError(f"Stooq returned HTML for symbol: {symbol}")
    try:
        df = pd.read_csv(StringIO(response.text))
    except pd.errors.ParserError as exc:
        raise ValueError(f"Unable to parse Stooq CSV for symbol: {symbol}") from exc
    normalized = {column.lower(): column for column in df.columns}
    if "date" not in normalized:
        raise ValueError(f"Stooq CSV missing Date column for symbol: {symbol}")
    df = df.rename(columns={normalized["date"]: "Date"})
    # Expected columns: Date, Open, High, Low, Close, Volume
    df["Date"] = pd.to_datetime(df["Date"], utc=True)
    df = df.sort_values("Date").set_index("Date")
    # Ensure numeric
    for c in ["Open", "High", "Low", "Close", "Volume"]:
        if c in df.columns:
            df[c] = pd.to_numeric(df[c], errors="coerce")
    required = {"Open", "High", "Low", "Close", "Volume"}
    missing = required.difference(df.columns)
    if missing:
        raise ValueError(f"Stooq CSV missing columns for symbol {symbol}: {sorted(missing)}")
    df = df.dropna(subset=["Close"])
    return df


# -----------------------------
# Optional FRED credit spread
# -----------------------------

def fetch_fred_series(series_id: str, api_key: str) -&gt; pd.DataFrame:
    """
    Pulls a FRED series via their JSON API.
    We keep it optional; dislocation detection works without it.
    """
    import urllib.parse

    base = "https://api.stlouisfed.org/fred/series/observations"
    params = {
        "series_id": series_id,
        "api_key": api_key,
        "file_type": "json",
    }
    url = base + "?" + urllib.parse.urlencode(params)
    r = requests.get(url, timeout=20)
    r.raise_for_status()
    data = r.json()
    obs = data.get("observations", [])
    rows = []
    for o in obs:
        dt = pd.to_datetime(o["date"], utc=True)
        val = o["value"]
        try:
            val = float(val)
        except ValueError:
            val = None
        rows.append((dt, val))
    df = pd.DataFrame(rows, columns=["Date", series_id]).dropna()
    df = df.set_index("Date").sort_index()
    return df


# -----------------------------
# Helpers
# -----------------------------

def pct_change(series: pd.Series, periods: int = 1) -&gt; pd.Series:
    return series.pct_change(periods=periods) * 100.0

def rolling_z(series: pd.Series, window: int) -&gt; pd.Series:
    mu = series.rolling(window).mean()
    sd = series.rolling(window).std(ddof=0)
    return (series - mu) / sd.replace(0, pd.NA)

def intraday_range_pct(df: pd.DataFrame) -&gt; pd.Series:
    # (High - Low) / Close * 100
    return (df["High"] - df["Low"]) / df["Close"] * 100.0

def safe_last(series: pd.Series) -&gt; float:
    return float(series.dropna().iloc[-1])

def any_recent_true(flag_series: pd.Series, lookback_days: int) -&gt; bool:
    s = flag_series.dropna()
    if s.empty:
        return False
    return bool(s.iloc[-lookback_days:].any())


# -----------------------------
# Signals
# -----------------------------

@dataclass
class SignalResult:
    name: str
    triggered: bool
    details: Dict[str, object]


def compute_signals(
    spy: pd.DataFrame,
    gld: pd.DataFrame,
    hyg: pd.DataFrame,
    vix: Optional[pd.DataFrame] = None,
    fred_hy_spread: Optional[pd.DataFrame] = None,
    lookback: int = 252,
) -&gt; List[SignalResult]:
    # Align on dates
    idx = spy.index.intersection(gld.index).intersection(hyg.index)
    # VIX may have different date stamps; align by intersection too
    if vix is not None:
        idx = idx.intersection(vix.index)
    spy = spy.loc[idx]
    gld = gld.loc[idx]
    hyg = hyg.loc[idx]
    if vix is not None:
        vix = vix.loc[idx]

    # Basic series
    spy_ret = pct_change(spy["Close"], 1)
    gld_ret = pct_change(gld["Close"], 1)
    hyg_ret = pct_change(hyg["Close"], 1)

    spy_rng = intraday_range_pct(spy)
    spy_rng_z = rolling_z(spy_rng, lookback)

    spy_vol = spy["Volume"].replace(0, pd.NA)
    spy_vol_z = rolling_z(spy_vol, lookback)

    vix_level = None
    vix_ret = None
    vix_level_z = None
    vix_ret_z = None
    if vix is not None:
        vix_level = vix["Close"]
        vix_ret = pct_change(vix_level, 1)
        vix_level_z = rolling_z(vix_level, lookback)
        vix_ret_z = rolling_z(vix_ret, lookback)

    # 1) Major indexes down big + whipsaw huge (stable: use both absolute and relative thresholds)
    big_down = spy_ret &lt;= -2.5
    whipsaw = (spy_rng &gt;= 2.5) | (spy_rng_z &gt;= 2.0)
    sig1 = big_down &amp; whipsaw

    # 2) "Bid-ask wider" proxy: liquidity degraded (range spike + volume spike)
    # We require BOTH to reduce false positives.
    liq_proxy = (spy_rng_z &gt;= 2.0) &amp; (spy_vol_z &gt;= 2.0)

    # 3) Volatility spike sharply (not just high):
    # Trigger if VIX is high *and* jumps unusually.
    if vix is None:
        vol_spike = pd.Series(False, index=idx)
    else:
        vol_spike = ((vix_level &gt;= 30) | (vix_level_z &gt;= 1.5)) &amp; ((vix_ret &gt;= 20) | (vix_ret_z &gt;= 2.0))

    # 4) Credit stress: HY underperforms equities a lot (flow stress)
    # Trigger when HYG drops meaningfully more than SPY in a day.
    credit_stress = (hyg_ret - spy_ret) &lt;= -1.5

    # Optional: FRED HY spread (weekly-ish, smoother)
    fred_flag = pd.Series(False, index=idx)
    fred_details = {}
    if fred_hy_spread is not None and not fred_hy_spread.empty:
        # Example series: "BAMLH0A0HYM2" (ICE BofA US High Yield OAS)
        series_id = fred_hy_spread.columns[0]
        # Align and forward-fill (spreads update daily-ish, sometimes lag)
        tmp = fred_hy_spread.reindex(idx, method="ffill")[series_id]
        # Dislocation-like widening: 5-day change &gt; 0.50 (50 bps) or z &gt; 2
        chg_5 = tmp.diff(5)
        z = rolling_z(tmp, lookback)
        fred_flag = (chg_5 &gt;= 0.50) | (z &gt;= 2.0)
        fred_details = {
            "hy_oas_level": safe_last(tmp),
            "hy_oas_5d_change": float(chg_5.dropna().iloc[-1]),
            "hy_oas_z": float(z.dropna().iloc[-1]),
        }

    # 5) Everything selling together: equities down hard AND gold down too.
    # This is a classic forced-liquidation tell (temporary correlation=1).
    everything_sells = (spy_ret &lt;= -2.0) &amp; (gld_ret &lt;= -1.0)

    # 6) Multiple forced-seller narratives: hard to scrape reliably without paid news.
    # Instead we use a "mechanical" proxy: big_down + credit_stress + vol_spike together.
    forced_flow_proxy = big_down &amp; credit_stress &amp; vol_spike

    # Build results for the latest day
    def latest_bool(s: pd.Series) -&gt; bool:
        s2 = s.dropna()
        return bool(s2.iloc[-1]) if not s2.empty else False

    results: List[SignalResult] = []

    results.append(SignalResult(
        name="big_down_and_whipsaw",
        triggered=latest_bool(sig1),
        details={"spy_1d_return_pct": safe_last(spy_ret), "spy_intraday_range_pct": safe_last(spy_rng), "spy_range_z": safe_last(spy_rng_z)},
    ))

    results.append(SignalResult(
        name="liquidity_degraded_proxy",
        triggered=latest_bool(liq_proxy),
        details={"spy_volume_z": safe_last(spy_vol_z), "spy_range_z": safe_last(spy_rng_z)},
    ))

    if vix is None:
        results.append(SignalResult(
            name="volatility_spike",
            triggered=False,
            details={"note": "VIX data unavailable from Stooq."},
        ))
    else:
        results.append(SignalResult(
            name="volatility_spike",
            triggered=latest_bool(vol_spike),
            details={"vix_level": safe_last(vix_level), "vix_1d_change_pct": safe_last(vix_ret), "vix_level_z": safe_last(vix_level_z), "vix_change_z": safe_last(vix_ret_z)},
        ))

    results.append(SignalResult(
        name="credit_stress_proxy",
        triggered=latest_bool(credit_stress),
        details={"hyg_1d_return_pct": safe_last(hyg_ret), "spy_1d_return_pct": safe_last(spy_ret), "hyg_minus_spy_pct": safe_last(hyg_ret - spy_ret)},
    ))

    if fred_hy_spread is not None and not fred_hy_spread.empty:
        results.append(SignalResult(
            name="credit_spread_widening_fred",
            triggered=latest_bool(fred_flag),
            details=fred_details,
        ))

    results.append(SignalResult(
        name="everything_sells_together",
        triggered=latest_bool(everything_sells),
        details={"spy_1d_return_pct": safe_last(spy_ret), "gld_1d_return_pct": safe_last(gld_ret)},
    ))

    if vix is None:
        results.append(SignalResult(
            name="forced_flow_proxy_combo",
            triggered=False,
            details={"spy_1d_return_pct": safe_last(spy_ret), "hyg_minus_spy_pct": safe_last(hyg_ret - spy_ret), "note": "VIX data unavailable from Stooq."},
        ))
    else:
        results.append(SignalResult(
            name="forced_flow_proxy_combo",
            triggered=latest_bool(forced_flow_proxy),
            details={"spy_1d_return_pct": safe_last(spy_ret), "hyg_minus_spy_pct": safe_last(hyg_ret - spy_ret), "vix_level": safe_last(vix_level), "vix_1d_change_pct": safe_last(vix_ret)},
        ))

    return results


def summarize_dislocation(
    signals: List[SignalResult],
    k_required: int = 3,
    persistence_days: int = 2,
) -&gt; Dict[str, object]:
    """
    Low-volatility decision rule:
      - Require &gt;=k signals triggered today
      - OR triggered today + within last N days (persistence) for stability
    Since we only computed "today" booleans in SignalResult, we implement
    a simple 'today count' rule here. For true persistence, you'd store
    prior outputs and apply smoothing.
    """
    triggered = [s for s in signals if s.triggered]
    count = len(triggered)

    return {
        "asof_utc": datetime.now(timezone.utc).isoformat(),
        "dislocation": bool(count &gt;= k_required),
        "signals_triggered_count": count,
        "signals_triggered": [s.name for s in triggered],
        "signals": [
            {"name": s.name, "triggered": s.triggered, "details": s.details}
            for s in signals
        ],
        "rule": {
            "k_required": k_required,
            "notes": "Designed to be low-churn: multiple independent stress signals must agree."
        }
    }


# -----------------------------
# CLI
# -----------------------------

def main() -&gt; None:
    ap = argparse.ArgumentParser()
    ap.add_argument("--output", default="dislocation.json", help="Output JSON path")
    ap.add_argument("--k", type=int, default=3, help="Signals required to flag dislocation")
    ap.add_argument("--lookback", type=int, default=252, help="Lookback window for z-scores")
    ap.add_argument("--vix-symbol", default=DEFAULT_TICKERS["vix"], help="Stooq symbol for VIX (try vix or ^vix)")
    ap.add_argument("--spy-symbol", default=DEFAULT_TICKERS["equity_core"], help="Stooq symbol for SPY proxy")
    ap.add_argument("--gld-symbol", default=DEFAULT_TICKERS["gold"], help="Stooq symbol for GLD")
    ap.add_argument("--hyg-symbol", default=DEFAULT_TICKERS["credit_hy"], help="Stooq symbol for HYG")
    ap.add_argument("--fred-series", default="", help="Optional FRED series id (e.g., BAMLH0A0HYM2)")
    args = ap.parse_args()

    spy = fetch_stooq_daily(args.spy_symbol)
    gld = fetch_stooq_daily(args.gld_symbol)
    hyg = fetch_stooq_daily(args.hyg_symbol)

    # VIX symbol sometimes differs; try a fallback automatically
    vix = None
    tried = []
    for candidate in [args.vix_symbol, "^vix", "vix"]:
        if candidate in tried:
            continue
        tried.append(candidate)
        try:
            vix = fetch_stooq_daily(candidate)
            break
        except ValueError:
            continue
    if vix is None:
        print(f"Warning: Unable to fetch VIX data from Stooq. Tried: {tried}")

    fred_df = None
    if args.fred_series:
        api_key = os.environ.get("FRED_API_KEY", "").strip()
        if api_key:
            fred_df = fetch_fred_series(args.fred_series, api_key)

    signals = compute_signals(spy=spy, gld=gld, hyg=hyg, vix=vix, fred_hy_spread=fred_df, lookback=args.lookback)
    summary = summarize_dislocation(signals, k_required=args.k)

    with open(args.output, "w", encoding="utf-8") as f:
        json.dump(summary, f, indent=2)

    print(json.dumps({"wrote": args.output, "dislocation": summary["dislocation"], "count": summary["signals_triggered_count"]}, indent=2))


if __name__ == "__main__":
    main()
</code></pre>
      </div>
    </section>

    <section class="section">
      <h2>How this hits your ‚Äúaccuracy + lack of volatility‚Äù requirement</h2>
      <div class="section-card">
        <h3>What‚Äôs accurate here</h3>
        <ul>
          <li>It uses <strong>observable market plumbing proxies</strong> that reliably show up in dislocations:</li>
          <li>outsized index down days + outsized intraday ranges</li>
          <li>VIX level + spike</li>
          <li>HY underperformance vs equities (credit stress)</li>
          <li>‚Äúeverything sells‚Äù pattern (forced liquidation)</li>
        </ul>
        <h3>What avoids twitchy false positives</h3>
        <ul>
          <li>Uses <strong>z-scores vs 1-year history</strong> (self-calibrating)</li>
          <li>Requires <strong>multiple independent signals</strong> (K-of-N rule)</li>
          <li>Uses <strong>both level AND change</strong> for VIX (so ‚ÄúVIX merely high‚Äù doesn‚Äôt trigger)</li>
          <li>Uses <strong>HYG relative</strong> (so ‚Äúmarket down because reasons‚Äù isn‚Äôt enough)</li>
        </ul>
      </div>
    </section>
  </main>
  <script>
    const statusEl = document.getElementById('dislocationStatus');
    const timestampEl = document.getElementById('dislocationTimestamp');
    const ruleEl = document.getElementById('dislocationRule');
    const signalsEl = document.getElementById('dislocationSignals');

    const formatStatus = (data) => data.dislocation ? 'Dislocation: TRUE' : 'Dislocation: false';
    const formatRule = (data) => {
      if (!data.rule) {
        return 'Rule: unavailable';
      }
      return `Rule: ${data.rule.k_required} signals required. ${data.rule.notes || ''}`.trim();
    };

    fetch('/dislocation.json')
      .then((response) => {
        if (!response.ok) {
          throw new Error('Failed to load dislocation.json');
        }
        return response.json();
      })
      .then((data) => {
        statusEl.innerHTML = `<strong>Status:</strong> ${formatStatus(data)} (${data.signals_triggered_count} signals)`;
        timestampEl.textContent = `As of: ${data.asof_utc || 'unknown'}`;
        ruleEl.textContent = formatRule(data);
        signalsEl.innerHTML = '';
        if (Array.isArray(data.signals)) {
          data.signals.forEach((signal) => {
            const li = document.createElement('li');
            li.textContent = `${signal.name}: ${signal.triggered ? 'triggered' : 'not triggered'}`;
            signalsEl.appendChild(li);
          });
        } else {
          const li = document.createElement('li');
          li.textContent = 'Signal details unavailable.';
          signalsEl.appendChild(li);
        }
      })
      .catch(() => {
        statusEl.innerHTML = '<strong>Status:</strong> Unable to load dislocation.json';
        timestampEl.textContent = 'As of: unavailable';
        ruleEl.textContent = 'Rule: unavailable';
        signalsEl.innerHTML = '<li>Signal details unavailable.</li>';
      });
  </script>
</body>
</html>
